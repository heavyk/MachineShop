// Generated by LiveScript 1.2.0
var assert, Postal, ToolShed, Debug, _, EventEmitter, debug, slice, pipeline, collective, Fsm, Empathy, out$ = typeof exports != 'undefined' && exports || this;
assert = require('assert');
Postal = require('postal');
ToolShed = require('./toolshed');
Debug = ToolShed.Debug, _ = ToolShed._, EventEmitter = ToolShed.EventEmitter;
debug = Debug('Fsm');
slice = [].slice;
pipeline = Postal.channel('Machina');
collective = {};
Fsm = (function(){
  Fsm.displayName = 'Fsm';
  var prototype = Fsm.prototype, constructor = Fsm;
  function Fsm(name, options){
    var args1, uniq, t, i$, ref$, len$, fn, key;
    this.once = bind$(this, 'once', prototype);
    this.on = bind$(this, 'on', prototype);
    this.emit = bind$(this, 'emit', prototype);
    this.emitSoon = bind$(this, 'emitSoon', prototype);
    this.transitionSoon = bind$(this, 'transitionSoon', prototype);
    this.execSoon = bind$(this, 'execSoon', prototype);
    this.exec = bind$(this, 'exec', prototype);
    this.error = bind$(this, 'error', prototype);
    this.reset = bind$(this, 'reset', prototype);
    this.once_initialized = bind$(this, 'once_initialized', prototype);
    args1 = slice.call(arguments, 1);
    do {
      uniq = Math.random().toString(32).substr(2);
      if (typeof name === 'string') {
        name += '.fsm.' + uniq;
      } else {
        options = name;
        name = 'fsm.' + uniq;
      }
    } while (collective[name]);
    this.debug = Debug(name);
    this._tasks = {};
    if (typeof options === 'object') {
      ToolShed.extend(this, options);
    }
    if (!this.eventListeners) {
      this.eventListeners = {};
    }
    if (!this.eventQueue) {
      this.eventQueue = [];
    }
    if (!this.namespace) {
      this.namespace = name;
    }
    if (!this.states) {
      throw new Error("really, a stateless state machine (" + this.namespace + ")???");
      this.states = {};
    }
    if (typeof this.initialState === 'undefined') {
      this.initialState = 'uninitialized';
    }
    if ((t = typeof this.initialize) !== 'undefined') {
      switch (t) {
      case 'function':
        this.initialize.apply(this, args1);
        break;
      case 'object':
        if (Array.isArray(this.initialize)) {
          for (i$ = 0, len$ = (ref$ = this.initialize).length; i$ < len$; ++i$) {
            fn = ref$[i$];
            if (typeof fn === 'function') {
              fn.apply(this, args1);
            }
          }
        } else {
          for (key in ref$ = this.initialize) {
            fn = ref$[key];
            if (typeof fn === 'function') {
              fn.apply(this, args1);
            }
          }
        }
      }
    }
    collective[name] = this;
    pipeline.publish('Fsm:added', {
      id: name
    });
    if (!this.state && this.initialState !== false) {
      this.debug("fsm transition initialState: " + this.initialState);
      this.transition(this.initialState);
    } else {
      this.debug("waiting to transition " + this.initialState);
    }
  }
  prototype.muteEvents = false;
  prototype.concurrency = Infinity;
  prototype._initialized = false;
  prototype.once_initialized = function(cb){
    assert(this instanceof Fsm);
    this.debug("once_initialized... %s", this._initialized);
    if (typeof cb === 'function') {
      if (this._initialized) {
        cb.call(this);
      } else {
        this.eventQueue.push({
          type: 'deferred',
          notState: this.initialState,
          cb: cb
        });
      }
    }
    return this._initialized;
  };
  prototype.reset = function(){
    this.state = void 8;
    if (typeof this.initialize === 'function') {
      this.initialize.call(this);
    }
    if (this.initialState) {
      return this.transitionSoon(this.initialState);
    }
  };
  prototype.error = function(err){
    var states, estate;
    states = this.states;
    if (typeof (estate = states[this.state].onerror) === 'function') {
      estate.call(this, err);
    } else if (this.eventListeners.error) {
      this.emit('error', err);
    }
    if (_machina) {
      return _machina.emit('Fsm:error', this, err.stack) || err + '';
    }
  };
  prototype.exec = function(cmd){
    var args, execd, state, states, handler, do_exec, fn, p, obj, this$ = this;
    args = slice.call(arguments, 0);
    execd = 0;
    this.debug("exec: " + cmd + " in " + this.state);
    if (!this.inExitHandler && (state = this.state)) {
      states = this.states;
      handler = cmd;
      do_exec = function(fn, handler, path){
        var args1, emit_obj, ret;
        args1 = args.slice(1);
        emit_obj = {
          cmd: cmd,
          handler: handler,
          path: path,
          args: args1
        };
        this$.emit.call(this$, 'executing', emit_obj);
        ret = fn.apply(this$, handler === '*' ? args : args1);
        this$.debug("exec(%s) called:ret (%s)", handler, typeof ret === 'object'
          ? 'object'
          : typeof ret === 'string' && ret.length > 100 ? ret.substr(0, 97) + ' ...' : ret);
        emit_obj.ret = ret;
        this$.emit.call(this$, 'executed', emit_obj);
        this$.emit.call(this$, "executed:" + handler, emit_obj);
        this$.processQueue('next-exec');
        execd++;
      };
      if (typeof (fn = states[state][handler]) === 'string') {
        handler = fn;
      }
      if (typeof (fn = states[state]['*']) === 'function') {
        do_exec(fn, '*', "/states/" + state + "/" + handler);
      }
      this.debug("handler " + handler);
      if ((p = this.cmds) && typeof (fn = p[handler]) === 'function') {
        do_exec(fn, handler, "/cmds/" + handler);
      }
      if (typeof (fn = states[state][handler]) === 'function') {
        do_exec(fn, handler, "/states/" + state + "/" + handler);
      }
    }
    if (execd === 0) {
      this.debug("exec: '" + cmd + "' next transition (in state:" + this.state);
      obj = {
        type: 'next-transition',
        cmd: cmd,
        args: args
      };
      return this.eventQueue.push(obj);
    }
  };
  prototype.execSoon = function(){
    var a, this$ = this;
    a = arguments;
    process.nextTick(function(){
      return this$.exec.apply(this$, a);
    });
  };
  prototype.transitionSoon = function(){
    var a, this$ = this;
    a = arguments;
    process.nextTick(function(){
      return this$.transition.apply(this$, a);
    });
  };
  prototype.transition = function(newState){
    var oldState, args1, args;
    if (typeof newState !== 'string') {
      newState = newState + '';
    }
    if (this.inTransition) {
      return this.transitionSoon.apply(this, arguments);
    }
    this.debug("fsm: transition %s -> %s", this.state, newState);
    if (!this.inExitHandler && newState !== this.state) {
      oldState = void 8;
      args1 = slice.call(arguments, 1);
      if (this.states[newState]) {
        this.inTransition = newState;
        this.targetReplayState = newState;
        this.priorState = this.state;
        this.state = newState;
        if (oldState = this.priorState) {
          if (this.states[oldState] && this.states[oldState].onexit) {
            this.inExitHandler = true;
            this.states[oldState].onexit.apply(this, args1);
            this.inExitHandler = false;
          }
        }
        if (this.states[newState].onenter) {
          this.states[newState].onenter.apply(this, args1);
        }
        if (oldState === this.initialState && !this._initialized) {
          this.debug("initialzed! in %s", newState);
          this._initialized = true;
        }
        this.debug("fsm: post-transition %s -> %s", oldState, newState);
        this.emit.apply(this, ["state:" + newState].concat(args1));
        this.emit.call(this, 'transition', {
          fromState: oldState,
          toState: newState,
          args: args = args1
        });
        this.processQueue.call(this, 'next-transition');
        this.processQueue.call(this, 'deferred');
        this.inTransition = null;
      } else {
        this.debug("attempted to transition to an invalid state: %s", newState);
        this.emit.call(this, 'invalid-state', {
          state: this.state,
          attemptedState: newState,
          args: args1
        });
      }
    }
  };
  prototype.processQueue = function(type){
    var filterFn, len_before, toProcess, this$ = this;
    filterFn = type === 'next-transition'
      ? function(item){
        return item.type === 'next-transition';
      }
      : type === 'deferred'
        ? function(item, i){
          return item.type === 'deferred' && ((item.untilState && item.untilState === this$.state) || (item.notState && item.notState !== this$.state));
        }
        : function(item){
          return item.type === 'next-exec';
        };
    len_before = this.eventQueue.length;
    toProcess = _.filter(this.eventQueue, filterFn);
    if (toProcess.length) {
      this.debug("processQueue:" + type + "(" + toProcess.length + ")");
    }
    _.each(toProcess, function(item){
      var fn, i;
      if (filterFn(item, i)) {
        fn = item.type === 'deferred'
          ? item.cb
          : this$.exec;
        fn.apply(this$, item.args);
        i = this$.eventQueue.indexOf(item);
        this$.eventQueue.splice(i, 1);
      }
    });
  };
  prototype.clearQueue = function(type, name){
    var filter, this$ = this;
    if (!type) {
      this.eventQueue = [];
    } else {
      filter = void 8;
      if (type === 'next-transition') {
        filter = function(evnt){
          return evnt.type === 'next-transition' && (name ? evnt.untilState === name : true);
        };
      } else {
        if (type === 'next-exec') {
          filter = function(evnt){
            return evnt.type === 'next-exec';
          };
        }
      }
      this.eventQueue = _.filter(this.eventQueue, filter);
    }
  };
  prototype.until = function(stateName, cb){
    var args, queued;
    args = slice.call(arguments, 2);
    if (this.state === stateName) {
      return cb.apply(this, args);
    } else {
      queued = {
        type: 'deferred',
        untilState: stateName,
        cb: cb,
        args: args
      };
      return this.eventQueue.push(queued);
    }
  };
  prototype.process = function(name){
    var args, task, this$ = this;
    args = arguments;
    task = this.task("processs:" + name);
    return task.start(function(task){
      return this$.processes[name].call(this$, task);
    });
  };
  prototype.task = function(scope, concurrency, name, cb){
    var _name, _concurrency, fsm, self, task, fn;
    _name = 'random task #9';
    _concurrency = Infinity;
    fsm = this;
    self = this;
    switch (typeof scope) {
    case 'function':
      cb = scope;
      break;
    case 'string':
      _name = scope;
      cb = concurrency;
      break;
    case 'number':
      cb = name;
      name = concurrency;
      concurrency = scope;
      break;
    case 'object':
      self = scope;
    }
    switch (typeof concurrency) {
    case 'string':
      _name = concurrency;
      cb = name;
      break;
    case 'number':
      _concurrency = concurrency;
    }
    if (typeof name === 'string') {
      _name = name;
    }
    task = new EventEmitter;
    task.name = name = _name;
    this.debug("new task '%s'", _name);
    task.scope = self;
    task.i = 0;
    task.running = 0;
    task.complete = 0;
    task.concurrency = concurrency = _concurrency;
    task.results = [];
    task.msgs = [];
    task.chokes = [];
    task.fns = [];
    task.wait = function(){
      var i;
      i = task.fns.length;
      if (task.chokes[i - 1] !== i) {
        fsm.debug("task[%s][%d]: choke", name, i);
        task.chokes.push(i);
      }
      return task;
    };
    task.choke = function(txt, fn){
      var i;
      if (typeof txt === 'function') {
        fn = txt;
        txt = null;
      }
      i = task.fns.length;
      fsm.debug("task[%s][%d]: choke", name, i);
      task.chokes.push(i);
      task.fns.push(fn);
      task.msgs.push(txt);
      if (!task._paused) {
        task.next();
      }
      return task;
    };
    task.push = function(txt, fn){
      var i;
      if (typeof txt === 'function') {
        fn = txt;
        txt = null;
      }
      i = task.fns.length;
      fsm.debug("task[%s][%d]: push - %s", name, i, txt);
      task.fns.push(fn);
      task.msgs.push(txt);
      if (!task._paused) {
        task.next();
      }
      return task;
    };
    task.end = function(cb){
      fsm.debug("task[%s][*]: end", name);
      task._cb = cb;
      if (task.fns.length) {
        task.next();
      } else {
        task._paused = true;
        if (typeof cb === 'function') {
          cb.call(scope, null, task.results, name);
        }
      }
      return task;
    };
    task.start = function(cb){
      var _cb, _task;
      fsm.debug("task[%s]: start", name);
      if (typeof (_cb = task._cb) === 'function') {
        _task = self.task(task.scope(task.concurrency, task.name));
        _cb.call(this, _task);
        return _task;
      }
      if (typeof cb === 'function') {
        task._cb = cb;
        process.nextTick(function(){
          cb.call(scope, task);
          if (task.fns.length) {
            return task.next();
          }
        });
      }
      return task;
    };
    task.failure = function(err){
      task._paused = true;
      return task.emit('failure', err);
    };
    task.success = function(res){
      return task.emit('success', res);
    };
    task.next = function(){
      var i, fn, is_choke, start, msg, done_fn;
      if (task._paused) {
        return;
      }
      i = task.i;
      fn = task.fns[i];
      is_choke = ~task.chokes.indexOf(i) ? true : false;
      if (typeof fn === 'undefined' || task.running >= task.concurrency || (is_choke && task.running !== 0)) {
        fsm.debug("task[%s][%d]: waiting.. not starting (running:%s/%s) choke:%s - %s", name, i, task.running, task.concurrency, is_choke, typeof fn);
        return;
      }
      start = new Date;
      task.i++;
      task.running++;
      msg = task.msgs[i];
      fsm.debug("task[%s][%d]: running... (complete:%d/%d) (%s)", name, i, task.complete, task.fns.length, task.msgs[i]);
      task.emit('running', {
        msg: msg,
        index: i,
        running: task.running,
        pending: {
          pending: task.complete - task.fns.length
        },
        total: task.fns.length
      });
      done_fn = function(err, res){
        var end, ref$, ref1$;
        task.running--;
        if (err) {
          task._paused = true;
          if (typeof task._cb === 'function') {
            task._cb.call(task.scope, err);
          }
          task.emit('error', err);
          return;
        }
        task.complete++;
        end = new Date;
        if (res) {
          task.results[i] = res;
        }
        fsm.debug("task[%s][%d] done (complete:%d/%d running:%d) (%s)", name, i, task.complete, task.fns.length, task.running, task.msgs[i]);
        task.emit('complete', {
          index: i,
          value: res,
          pending: task.complete - task.fns.length,
          total: task.fns.length,
          complete: task.complete,
          msg: msg,
          percent: task.complete / task.fns.length * 100 | 0,
          start: start,
          end: end,
          duration: end - start
        });
        if (task.running + task.complete < task.fns.length) {
          return process.nextTick(function(){
            return task.next();
          });
        } else if (task.running === 0) {
          if (typeof task._cb === 'function') {
            fsm.debug("task[%s][*]: completed all tasks %d/%d (" + typeof task._cb + ")", name, task.complete, task.fns.length);
            task._cb.call(task.scope, null, task.results, name);
          }
          task.emit('end', null, task.results, name);
          return ref1$ = (ref$ = self._tasks)[name], delete ref$[name], ref1$;
        }
      };
      done_fn.dover = function(times, error){
        if (typeof times === 'undefined') {
          times = 2;
        }
        self.debug;
        done_fn.dover = done_fn._dover(times, error);
        return done_fn.dover();
      };
      done_fn._dover = function(times, error){
        return function(){
          if (times--) {
            self.debug("running... task remaining lives: " + times);
            return fn.call(task.scope, done_fn);
          } else {
            return done_fn(error || new Error("retry failed for task '" + msg + "'"));
          }
        };
      };
      process.nextTick(function(){
        return fn.call(task.scope, done_fn);
      });
      if (!is_choke && task.running + task.complete < task.fns.length) {
        return task.next();
      }
    };
    task.emit('task:added', task);
    if (this._tasks[name]) {
      throw new Error("task '" + name + "' already exists");
    }
    if (typeof cb === 'function') {
      task.start(cb);
    }
    if (this.tasks && typeof (fn = this.tasks[name]) === 'function') {
      t.start(fn);
    }
    return this._tasks[name] = task;
  };
  prototype.emitSoon = function(){
    var a, this$ = this;
    a = arguments;
    return process.nextTick(function(){
      return this$.emit.apply(this$, a);
    });
  };
  prototype.emit = function(eventName){
    var args, doEmit, this$ = this;
    if (this.muteEvents) {
      return;
    }
    args = arguments;
    doEmit = function(){
      var listeners, args1;
      if (this$.debug.online) {
        switch (eventName) {
        case 'executing':
          this$.debug("executing: (%s:%s)", this$.state, args[1].handler);
          break;
        case 'executed':
          this$.debug("executed: (%s:%s)", this$.state, args[1].handler);
          break;
        case 'invalid-state':
          this$.debug.error("bad transition: (%s !-> %s)", args[1].state, args[1].attemptedState);
          break;
        case 'transition':
          this$.debug("transition: (%s -> %s)", args[1].fromState, args[1].toState);
          break;
        default:
          this$.debug("emit: (%s): num args %s", eventName, args.length - 1);
        }
      }
      if (listeners = this$.eventListeners['*']) {
        if (typeof listeners === 'function') {
          listeners.apply(this$, args);
        } else {
          _.each(this$.eventListeners['*'], function(callback){
            return callback.apply(this, args);
          }, this$);
        }
      }
      if (listeners = this$.eventListeners[eventName]) {
        args1 = slice.call(args, 1);
        if (typeof listeners === 'function') {
          return listeners.apply(this$, args1);
        } else {
          return _.each(listeners, function(callback){
            return callback.apply(this$, args1);
          });
        }
      }
    };
    doEmit.call(this);
    return this;
  };
  prototype.on = function(eventName, real_cb, callback){
    var listeners, this$ = this;
    if (typeof callback !== 'function') {
      callback = real_cb;
      real_cb = void 8;
    }
    listeners = this.eventListeners[eventName];
    if (this.eventListeners === this.__proto__.eventListeners) {
      this.eventListeners = _.cloneDeep(this.eventListeners);
    }
    if (!listeners) {
      this.eventListeners[eventName] = [];
    }
    if (typeof listeners === 'function') {
      this.eventListeners[eventName] = [listeners];
    }
    this.eventListeners[eventName].push(callback);
    if (eventName.substr(0, 6) === "state:" && this.state === eventName.substr(6)) {
      process.nextTick(function(){
        return callback.call(this$);
      });
    }
    return {
      eventName: eventName,
      callback: callback,
      cb: real_cb,
      off: function(){
        return this$.off(eventName, callback);
      }
    };
  };
  prototype.once = function(eventName, callback){
    var evt, this$ = this;
    return evt = this.on(eventName, callback, function(){
      evt.cb.apply(this$, arguments);
      process.nextTick(function(){
        return evt.off(eventName, callback);
      });
    });
  };
  prototype.off = function(eventName, callback){
    var i;
    if (!eventName) {
      return this.eventListeners = {};
    } else {
      if (this.eventListeners[eventName]) {
        if (callback) {
          if (~(i = this.eventListeners[eventName].indexOf(callback))) {
            return this.eventListeners[eventName].splice(i, 1);
          }
        } else {
          return this.eventListeners[eventName] = [];
        }
      }
    }
  };
  return Fsm;
}());
Empathy = {
  derivative: function(name, version){
    if (version) {
      return Semver.satisfies(version, this._derivatives[name]);
    } else {
      return this._derivatives[name];
    }
  },
  derivatives: {
    'node-webkit': function(cb){
      return cb(typeof process === 'object' && typeof process.versions === 'object' ? process.versions['node-webkit'] : void 8);
    },
    node: function(cb){
      return cb(typeof process === 'object' && typeof process.versions === 'object' ? process.versions.node : void 8);
    },
    browser: function(cb){
      return cb(typeof window === 'object' && typeof window.navigator === 'object' ? window.navigator.version : void 8);
    }
  },
  'also|initialize': function(){
    var task, this$ = this;
    task = this.task('check derivatives');
    if (typeof this._derivatives === 'undefined') {
      this._derivatives = {};
      this.__derivatives = [];
    }
    _.each(this.derivatives, function(d, k){
      return task.push("checking for " + k, function(done){
        return d(function(v){
          this$.debug("d:ret:" + k + " %s", v);
          if (v) {
            this$._derivatives[k] = v;
            this$.__derivatives.push(k);
            this$.debug("found derivative " + k + "@" + v);
          }
          return done(void 8, v);
        });
      });
    });
    this.on('derivative:remove', function(){
      return this.debug.todo("go through each one and remove the derivative version from the extended function");
    });
    this.on('derivative:add', function(){
      return this.debug.todo("go through each one and add the derivative versions to the extended function list if it's not already");
    });
    this.on('state:added', function(state){
      return this.debug.todo("calculate the derivatives");
    });
    task.end(function(){
      var transition, exec;
      this$.emit('derivatives:calculated');
      transition = function(e){
        var i$, ref$, len$, derivative, v, d, results$ = [];
        for (i$ = 0, len$ = (ref$ = this$.__derivatives).length; i$ < len$; ++i$) {
          derivative = ref$[i$];
          v = this$._derivatives[derivative];
          if (e.fromState && (d = this$.states[e.fromState][derivative + ":onexit"])) {
            d.apply(this$, e.args);
          }
          if (d = this$.states[e.toState][derivative + ":onenter"]) {
            results$.push(d.apply(this$, e.args));
          }
        }
        return results$;
      };
      exec = function(e){
        var i$, ref$, len$, derivative, v, d, dd, results$ = [];
        for (i$ = 0, len$ = (ref$ = this$.__derivatives).length; i$ < len$; ++i$) {
          derivative = ref$[i$];
          v = this$._derivatives[derivative];
          if ((d = this$.states[derivative + ":" + this$.state]) && (dd = d[e.cmd])) {
            dd.apply(this$, e.args);
          }
          if ((d = this$.cmds) && (dd = d[derivative + ":" + e.cmd])) {
            results$.push(dd.apply(this$, e.args));
          }
        }
        return results$;
      };
      this$.on('transition', transition);
      this$.on('executed', exec);
      if (this$.state) {
        this$.debug("re-emit " + this$.initialState);
        if (this$.initialState !== this$.state) {
          transition({
            toState: this$.initialState,
            args: []
          });
        }
        return transition({
          fromState: this$.priorState,
          toState: this$.state,
          args: []
        });
      }
    });
  }
};
Fsm.Empathy = Empathy;
out$.Empathy = Empathy;
out$.Fsm = Fsm;
out$.pipeline = pipeline;
out$.collective = collective;
/*
#TODO: convert this into a real test...
fsm = new Fsm {
	states:
		uninitialized:
			onenter: ->
				console.log "uninitialized"
				task = @task 'lala1'
				task.choke (done) ->
					setTimeout ->
						done null, 1
					, 1500
				task.push (done) ->
					setTimeout ->
						done null, 2
					, 1600
				task.push (done) ->
					setTimeout ->
						done null, 3
					, 1700
				task.push (done) ->
					setTimeout ->
						done null, 4
					, 1800
				task.push (done) ->
					setTimeout ->
						done null, 5
					, 1900
				task.push (done) ->
					setTimeout ->
						done null, 6
					, 2000

				sub1 = task.branch 'sub1'
				sub1.push (done) -> done null, 1
				sub1.push (done) ->
					setTimeout ->
						done null, 1
					, 2500
				sub1.push (done) ->
					setTimeout ->
						done null, 2
					, 3000
				sub1.choke (done) ->
					setTimeout ->
						done null, 3
					, 1000
				sub1.push (done) ->
					setTimeout ->
						done null, 5
					, 3000
				sub1.push (done) ->
					setTimeout ->
						done null, 4
					, 1000
				task.push (done) -> sub1.end done

				task.push (done) -> done null, 6
				#(err, res) <- task.end
				console.log "here", &
				task.choke (done) ->
					setTimeout ->
						done null, 7
					, 2000
				#(err, res) <- task.end
				task.choke (done) ->
					setTimeout ->
						done null, 8
					, 2000

				task.end (err, res) ->
					console.log "task end", &

}
#*/
/*
fsm = new Fsm {
	states:
		uninitialized:
			onenter: ->
				console.log "uninitialized"
				task = @task 'lala2'
				task.push (done) -> done null, 1
				task.end (err, res) ->
					console.log "task end", &

}
#*/
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}