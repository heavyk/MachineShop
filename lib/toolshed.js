// Generated by LiveScript 1.2.0
var Fs, Path, Url, assert, spawn, mkdirp, Rimraf, printf, EventEmitter, _, nw_version, v8_version, HOME_DIR, v8_mode, Debug, debug, Fiber, Future, Environment, scan, parse, rimraf, isDirectory, unquote, isQuoted, stripEscapeCodes, mkdir, exists, stat, readdir, readFile, writeFile, exec, searchDownwardFor, recursive_hardlink, debug_fn, get_obj_path, set_obj_path, out$ = typeof exports != 'undefined' && exports || this;
Fs = require('fs');
Path = require('path');
Url = require('url');
assert = require('assert');
spawn = require('child_process').spawn;
mkdirp = require('mkdirp');
Rimraf = require('rimraf');
printf = require('printf');
EventEmitter = require('eventemitter3').EventEmitter;
_ = require('lodash');
nw_version = process.versions ? process.versions['node-webkit'] : void 8;
v8_version = (nw_version ? 'nw' : 'node') + '_' + process.platform + '_' + process.arch + '_' + (process.versions
  ? process.versions.v8.match(/^([0-9]+)\.([0-9]+)\.([0-9]+)/)[0] + '-' + process.versions.modules
  : typeof window === 'object' ? 'browser' : 'unknown');
HOME_DIR = process.platform === 'win32'
  ? process.env.USERPROFILE
  : process.env.HOME;
v8_mode = 'Release';
Debug = function(namespace){
  var path, do_append_msg, debug, start;
  if (!(path = Debug.namespaces[namespace])) {
    path = process.cwd();
  }
  do_append_msg = function(channel, prefix, postfix){
    var _write, write;
    _write = function(msg, channel, prefix, postfix){
      if (typeof postfix !== 'string') {
        postfix = '\n';
      } else if (postfix[postfix.length - 1] !== '\n') {
        postfix += '\n';
      }
      Fs.appendFileSync(path, prefix + msg + postfix);
    };
    if (typeof channel === 'function') {
      write = channel;
      channel = 'debug';
      prefix = '';
    }
    if (typeof prefix === 'function') {
      write = prefix;
      prefix = '';
    }
    if (typeof postfix === 'function') {
      write = postfix;
    }
    if (typeof write !== 'function') {
      write = _write;
    } else if (typeof postfix !== 'string') {
      postfix = '';
    }
    return function(){
      var msg;
      msg = printf.apply(this, arguments);
      write(msg, channel, prefix, postfix, _write);
      if (this.emit) {
        this.emit(channel ? "debug:" + channel : 'debug', {
          message: msg
        });
      }
    };
  };
  if (HOME_DIR && !process.env.DEBUG) {
    debug = do_append_msg('debug', "[DEBUG] " + namespace + ": ");
    debug.warn = do_append_msg('warn', "[WARN] " + namespace + ": ");
    debug.info = do_append_msg('info', "[INFO] " + namespace + ": ");
    debug.todo = do_append_msg('todo', "[TODO] " + namespace + ": ", function(msg, channel, prefix, postfix, write){
      var e, stack, i, s;
      try {
        throw new Error("TODO: error");
      } catch (e$) {
        e = e$;
        stack = e.stack.split('\n');
        postfix += '\n';
        i = 3;
        if (~stack[i].indexOf('do_exec')) {
          i += 1;
        }
        if (~(s = stack[i].indexOf('prototype.exec'))) {
          i += 1;
        }
        postfix += "\n    at " + stack[i].trim();
      }
      write(msg, channel, prefix, postfix);
    });
    debug.error = do_append_msg("[ERROR] " + namespace + ": ", 'error');
    debug.log = do_append_msg("[LOG] " + namespace + ": ", 'log');
    start = function(){
      path = Path.join(HOME_DIR, '.ToolShed', "debug.log");
      return mkdirp(Path.dirname(path), function(err){
        Fs.writeFileSync(path, "");
        return debug("Debug(" + namespace + ") starting at '" + path + "'");
      });
    };
    debug.namespace = [
      ~function(){
        return namespace;
      }, ~function(v){
        start();
        return namespace = v;
      }
    ];
    debug.assert = assert;
    start();
  } else {
    if (console.debug) {
      debug = do_append_msg('debug', " [DEBUG - " + namespace + "]: ", function(msg, channel, prefix, postfix){
        return console.debug(msg + postfix);
      });
    } else {
      debug = do_append_msg('debug', " [DEBUG - " + namespace + "]: ", function(msg, channel, prefix, postfix){
        return console.log(prefix + msg + postfix);
      });
    }
    debug.todo = do_append_msg('todo', " [INFO - " + namespace + "]: ", function(msg, channel, prefix, postfix){
      return console.info('[TODO] ' + msg + postfix);
    });
    debug.warn = do_append_msg('warn', " [WARN " + namespace + "]: ", function(msg, channel, prefix, postfix){
      return console.warn(msg + postfix);
    });
    debug.info = do_append_msg('info', " [INFO " + namespace + "]: ", function(msg, channel, prefix, postfix){
      return console.info(msg + postfix);
    });
    debug.error = do_append_msg('error', " [ERROR " + namespace + "]: ", function(msg, channel, prefix, postfix){
      return console.error(msg + postfix);
    });
    debug.log = do_append_msg('log', " [LOG " + namespace + "]: ", function(msg, channel, prefix, postfix){
      return console.log(msg + postfix);
    });
    debug.assert = assert;
    debug.namespace = [
      ~function(){
        return namespace;
      }, ~function(v){
        return namespace = v;
      }
    ];
  }
  return debug;
};
Debug.namespaces = {};
Debug.colors = true;
debug = Debug('ToolShed');
Fiber = function(){};
Future = function(){};
Environment = (function(){
  Environment.displayName = 'Environment';
  var prototype = Environment.prototype, constructor = Environment;
  prototype._bp = {
    idea: 'Environment'
  };
  function Environment(env){
    if (typeof env !== 'object') {
      env = process.env;
    }
    this.nw_version = process.versions ? process.versions['node-webkit'] : void 8;
    this.v8_version = (nw_version ? 'nw' : 'node') + '_' + process.platform + '_' + process.arch + '_' + (process.versions
      ? process.versions.v8.match(/^([0-9]+)\.([0-9]+)\.([0-9]+)/)[0] + '-' + process.versions.modules
      : typeof window === 'object' ? 'browser' : 'unknown');
    this.HOME_DIR = process.platform === 'win32'
      ? process.env.USERPROFILE
      : process.env.HOME;
    this.env = env;
  }
  return Environment;
}());
scan = function(str){
  var re, toks, tok, m, braceExpand;
  re = /(?:(\S*"[^"]+")|(\S*'[^']+')|(\S+))/g;
  toks = [];
  tok = void 8;
  m = void 8;
  braceExpand = require('minimatch').braceExpand;
  while (m = re.exec(str)) {
    tok = m[0];
    tok = braceExpand(tok, {
      nonegate: true
    });
    toks = toks.concat(tok);
  }
  return toks;
};
parse = function(str){
  var toks, cmds, cmd, i$, len$, i, tok, part;
  toks = scan(str);
  cmds = [];
  cmd = {
    env: {},
    argv: []
  };
  for (i$ = 0, len$ = toks.length; i$ < len$; ++i$) {
    i = i$;
    tok = toks[i$];
    if ('|' === tok) {
      continue;
    }
    if (tok.indexOf('=') > 0) {
      part = tok.split('=');
      cmd.env[part.shift()] = unquote(part.join('='));
    } else {
      cmd.name = tok;
      while (toks[i + 1] && toks[i + 1] !== '|') {
        cmd.argv.push(toks[++i]);
      }
      cmds.push(cmd);
      cmd = {
        env: {},
        argv: []
      };
    }
  }
  return cmds;
};
rimraf = function(dir, cb){
  if (typeof cb === 'function') {
    return Rimraf(dir, cb);
  } else {
    return Rimraf(dir, function(){});
  }
};
isDirectory = function(path){
  var s, err;
  debug("isDirectory %s", path);
  try {
    s = stat(path);
    return s.isDirectory();
  } catch (e$) {
    err = e$;
    return false;
  }
};
unquote = function(str){
  return str.replace(/^"|"$/g, '').replace(/^'|'$/g, '').replace(/\n/g, '\n');
};
isQuoted = function(str){
  return '"' === str[0] || '\'' === str[0];
};
stripEscapeCodes = function(str){
  return str.replace(/\033\[[^m]*m/g, '');
};
mkdir = function(path, cb){
  var future;
  debug("mkdir %s -> %s", path, typeof cb === 'function'
    ? 'callback'
    : Fiber.current ? 'fiber' : 'sync');
  if (typeof cb === 'function') {
    return mkdirp(path, cb);
  } else if (Fiber.current) {
    future = new Future;
    mkdirp(path, function(err, d){
      return future['return'](err) || d;
    });
    return future.wait();
  } else {
    return mkdirp.sync(path);
  }
};
exists = function(path, cb){
  var future, v;
  debug("exists %s -> %s", path, typeof cb === 'function'
    ? 'callback'
    : Fiber.current ? 'fiber' : 'sync');
  if (typeof cb === 'function') {
    return Fs.exists(path, cb);
  } else if (Fiber.current) {
    future = new Future;
    Fs.exists(path, function(exists){
      return future['return'](exists);
    });
    v = future.wait();
    return v;
  } else {
    return Fs.existsSync(path);
  }
};
stat = function(path, cb){
  var future;
  debug("stat %s -> %s", path, typeof cb === 'function'
    ? 'callback'
    : Fiber.current ? 'fiber' : 'sync');
  if (typeof cb === 'function') {
    return Fs.stat(path, cb);
  } else if (Fiber.current) {
    future = new Future;
    Fs.stat(path, function(err, st){
      return future['return'](err) || st;
    });
    return future.wait();
  } else {
    return Fs.statSync(path);
  }
};
readdir = function(path, cb){
  var future, files, err;
  debug("readdir(%s) %s", path, typeof cb === 'function'
    ? 'callback'
    : Fiber.current ? 'fiber' : 'sync');
  if (typeof cb === 'function') {
    return Fs.readdir(path, cb);
  } else if (Fiber.current) {
    future = new Future;
    Fs.readdir(path, function(err, files){
      if (!err) {
        _.each(files, function(file, i){
          var f;
          f = {};
          Object.defineProperty(f, 'st', {
            get: function(){
              return stat(file);
            }
          });
          return Object.defineProperty(f, 'toString', {
            get: function(){
              return file;
            }
          });
        });
      }
      return future['return'](err) || files;
    });
    return future.wait();
  } else {
    try {
      files = Fs.readdirSync(path);
      _.each(files, function(file, i){
        var f;
        f = {};
        Object.defineProperty(f, 'st', {
          get: function(){
            return stat(file);
          }
        });
        return Object.defineProperty(f, 'toString', {
          get: function(){
            return file;
          }
        });
      });
    } catch (e$) {
      err = e$;
      throw err;
    }
    return files;
  }
};
readFile = function(path, enc, cb){
  var future;
  debug("readFile %s -> %s", path, typeof cb === 'function'
    ? 'callback'
    : Fiber.current ? 'fiber' : 'sync');
  if (typeof enc === 'function') {
    cb = enc;
    enc = 'utf-8';
  }
  if (typeof cb === 'function') {
    return Fs.readFile(path, enc, cb);
  } else if (Fiber.current) {
    future = new Future;
    Fs.readFile(path, enc, function(err, st){
      return future['return'](err) || st;
    });
    return future.wait();
  } else {
    return Fs.readFileSync(path, enc);
  }
};
writeFile = function(path, data, cb){
  var future;
  debug("writeFile %s -> %s", path, typeof cb === 'function'
    ? 'callback'
    : Fiber.current ? 'fiber' : 'sync');
  if (typeof cb === 'function') {
    return Fs.writeFile(path, data, cb);
  } else if (Fiber.current) {
    future = new Future;
    Fs.writeFile(path, data, function(err, st){
      return future['return'](err) || st;
    });
    return future.wait();
  } else {
    return Fs.writeFileSync(path, data);
  }
};
exec = function(cmd, opts, cb){
  var cmds, p;
  if (typeof opts === 'function') {
    cb = opts;
    opts = {
      stdio: 'inherit'
    };
  }
  if (!opts.stdio) {
    opts.stdio = 'inherit';
  }
  if (!opts.env) {
    opts.env = process.env;
  }
  cmds = cmd.split(' ');
  p = spawn(cmds[0], cmds.slice(1), opts);
  p.on('error', function(err){
    opts.env = "omitted";
    debug("exec '" + cmd + "' failed %s", DaFunk.stringify(opts));
    return cb(err);
  });
  return p.on('close', function(code){
    if (code) {
      return cb(new Error("exit code: " + code));
    } else {
      return cb(code);
    }
  });
};
searchDownwardFor = function(file, dir, cb){
  var test_dir;
  if (typeof dir === 'function') {
    cb = dir;
    dir = process.cwd();
  }
  test_dir = function(dir){
    var path;
    path = Path.join(dir, file);
    debug("testing %s", path);
    return Fs.stat(path, function(err, st){
      if (err) {
        if (err.code === 'ENOENT') {
          dir = Path.resolve(dir, '..');
          if (dir === Path.sep) {
            return cb(err);
          } else {
            return test_dir(dir);
          }
        }
      } else if (st.isFile()) {
        return cb(null, path);
      } else {
        return console.log("....", st);
      }
    });
  };
  return test_dir(dir);
};
recursive_hardlink = function(path, into, cb){
  var rh, future, files, err;
  debug("recursive_hardlink %s -> %s", path, into, typeof cb === 'function'
    ? 'callback'
    : Fiber.current ? 'fiber' : 'sync');
  rh = function(done){
    return Fs.readdir(path, function(err, files){
      if (err) {
        return cb(err);
      }
    });
  };
  if (typeof cb === 'function') {
    return Fs.readdir(path, cb);
  } else if (Fiber.current) {
    future = new Future;
    Fs.readdir(path, function(err, files){
      if (!err) {
        _.each(files, function(file, i){
          var f;
          f = {};
          Object.defineProperty(f, 'st', {
            get: function(){
              return stat(file);
            }
          });
          return Object.defineProperty(f, 'toString', {
            get: function(){
              return file;
            }
          });
        });
      }
      return future['return'](err) || files;
    });
    return future.wait();
  } else {
    try {
      files = Fs.readdirSync(path);
      _.each(files, function(file, i){
        var f;
        f = {};
        Object.defineProperty(f, 'st', {
          get: function(){
            return stat(file);
          }
        });
        return Object.defineProperty(f, 'toString', {
          get: function(){
            return file;
          }
        });
      });
    } catch (e$) {
      err = e$;
      throw err;
    }
    return files;
  }
};
debug_fn = function(namespace, cb, not_fn){
  if (typeof namespace === 'function') {
    cb = not_fn;
    cb = namespace;
    namespace = void 8;
  }
  return function(){
    if (typeof cb === 'function') {
      if (!namespace || (typeof namespace === 'string' && ~DEBUG.indexOf(namespace)) || (namespace instanceof RegEx && namespace.exec(DEBUG))) {
        debugger;
      }
      return cb.apply(this, arguments);
    } else if (!not_fn) {
      throw new Error("can't debug a function this not really a function");
    }
  };
};
get_obj_path = function(path, obj){
  var i;
  assert(typeof path === 'string');
  if (typeof obj === 'undefined') {
    obj = this;
  }
  path = path.split('.');
  i = 0;
  while (i < path.length) {
    obj = obj[path[i++]];
  }
  return obj;
};
set_obj_path = function(path, obj, val, split){
  var i, ii, paths, i$, ref$, len$, p, subobj;
  if (typeof path !== 'string') {
    throw new Error("arg{1:path} is supposed to be a string");
  }
  if (typeof obj !== 'function' && typeof obj !== 'object') {
    throw new Error("arg{2:val} must be an Object or a Function");
  }
  if (typeof val === 'undefined') {
    throw new Error("arg{3:val} cannot be undefined");
  }
  if (typeof split === 'undefined') {
    split = '/';
  }
  if (typeof split !== 'string') {
    throw new Error("arg{4:split} is supposed to be a string");
  }
  if (typeof val === 'undefined') {
    obj = this;
  }
  if (~(i = path.indexOf('{')) && ~(ii = path.lastIndexOf('}'))) {
    paths = path.substr(i + 1, ii - 1);
    for (i$ = 0, len$ = (ref$ = path = paths.split(',')).length; i$ < len$; ++i$) {
      p = ref$[i$];
      path = p.trim();
      set_obj_path(path.substr(0, i) + "" + p + path.substr(i + 1), obj, val[p]);
    }
    return;
  }
  if ((paths = path.split('.')).length) {
    subobj = obj;
    while (paths.length > 1) {
      subobj = obj[p = paths.shift().trim()];
      if (typeof subobj === 'undefined') {
        subobj = {};
        subobj[p] = val;
      }
    }
    return obj[p = paths.shift().trim()] = val;
  } else {
    return debug.warn("could not find a path to set to. this is probably not intended");
  }
};
out$._ = _;
out$.EventEmitter = EventEmitter;
out$.nw_version = nw_version;
out$.v8_version = v8_version;
out$.HOME_DIR = HOME_DIR;
out$.Environment = Environment;
out$.v8_mode = v8_mode;
out$.Debug = Debug;
out$.Future = Future;
out$.parse = parse;
out$.rimraf = rimraf;
out$.isDirectory = isDirectory;
out$.unquote = unquote;
out$.isQuoted = isQuoted;
out$.stripEscapeCodes = stripEscapeCodes;
out$.mkdir = mkdir;
out$.exists = exists;
out$.stat = stat;
out$.readdir = readdir;
out$.readFile = readFile;
out$.writeFile = writeFile;
out$.exec = exec;
out$.searchDownwardFor = searchDownwardFor;
out$.recursive_hardlink = recursive_hardlink;
out$.debug_fn = debug_fn;
out$.get_obj_path = get_obj_path;
out$.set_obj_path = set_obj_path;