// Generated by LiveScript 1.2.0
var Scope, out$ = typeof exports != 'undefined' && exports || this;
Scope = function(scope_name, initial_obj, save_fn){
  var debug, WeakMap, Proxy, Reflect, ee, scope, written_json_str, iid, save, make_reflective;
  debug = Debug('scope:' + scope_name);
  WeakMap = global.WeakMap;
  Proxy = global.Proxy;
  Reflect = global.Reflect;
  if (typeof WeakMap === 'undefined') {
    WeakMap = global.WeakMap = require('es6-collections').WeakMap;
  }
  if (typeof Proxy === 'undefined' && !process.versions['node-webkit']) {
    global.Proxy = Proxy = require('node-proxy');
  }
  if (typeof Reflect === 'undefined') {
    require('harmony-reflect');
    Reflect = global.Reflect;
  }
  ee = new EventEmitter;
  if (typeof initial_obj === 'function') {
    save_fn = initial_obj;
    initial_obj = void 8;
  }
  iid = false;
  save = function(){
    var clear_interval;
    clear_interval = function(){
      if (!Scope._saving[scope_name]) {
        clearInterval(iid);
        return iid = false;
      }
    };
    Scope._saving[scope_name]++;
    if (iid === false) {
      return iid = setInterval(function(){
        var obj, json_str;
        obj = scope;
        json_str = JSON.stringify(obj);
        if (json_str !== written_json_str) {
          written_json_str = json_str;
          if (typeof save_fn === 'function') {
            save_fn(obj);
          }
          ee.emit('save', obj, scope_name, json_str);
          clear_interval();
        } else {
          clear_interval();
        }
        return Scope._saving[scope_name] = 0;
      }, 500);
    }
  };
  make_reflective = function(o, oon){
    var oo, reflective, k, v;
    oo = Array.isArray(o)
      ? []
      : {};
    reflective = Reflect.Proxy(oo, {
      enumerable: true,
      enumerate: function(obj){
        return Object.keys(oo);
      },
      hasOwn: function(obj, key){
        return typeof oo[key] !== 'undefined';
      },
      keys: function(){
        return Object.keys(oo);
      },
      get: function(obj, name){
        var v, args, body;
        if (name === 'toJSON') {
          return function(){
            return oo;
          };
        } else if (name === 'inspect') {
          return function(){
            return require('util').inspect(oo);
          };
        } else if ((v = oo[name]) === 8 && oo[name + '.js']) {
          v = oo[name + '.js'];
          args = v.match(/function \((.*)\)/);
          body = v.substring(1 + v.indexOf('{'), v.lastIndexOf('}'));
          return oo[name] = Function(args[1], body);
        } else if (typeof v !== 'undefined') {
          return v;
        } else if (oon.length === 0) {
          return ee[name];
        }
      },
      set: function(obj, name, val){
        var prev_val, prop;
        prev_val = oo[name];
        if ((typeof val === 'object' && !_.isEqual(oo[name], val)) || oo[name] !== val) {
          prop = oon ? oon + "." + name : name;
          if (typeof val === 'object' && v !== null) {
            val = make_reflective(val, prop);
          }
          if (Array.isArray(val)) {
            debug("TODO: add the addedAt / removedAt events (see code)");
            /*
            new_objs = []
            existing_objs = []
            removed = []
            for d in docs => new_objs.push d._id.toHexString!
            for d in _docs => existing_objs.push d._id.toHexString!
            
            for id, i in existing_objs
            	if ~(ii = new_objs.indexOf id)
            		if ii is i and _dd = _docs[i] and d = docs[i]
            			dd = d.toObject!
            			_dd = _dd.toObject!
            			_.each dd, (v, k) ~>
            				# for now, I think the safest comparison we can do is simply converting both sides to a string:
            				if k isnt \_id and _dd[k]+'' isnt v+''
            					_docs.splice i, 1, d
            					ee.emit \changedAt, d, _docs[i], i
            	else
            		console.log id, "NOT found in new objs", i
            		removed.push id
            
            for id in removed
            	if ~(i = existing_objs.indexOf id)
            		ee.emit \removedAt, _docs[i], i
            		_docs.splice i, 1
            		existing_objs.splice i, 1
            	else
            		console.error "undefined error", id
            
            for id, i in new_objs
            	#id = d._id.toHexString!
            	if ~(ii = existing_objs.indexOf id)
            		if ii isnt i
            			existing_objs.splice ii, 1
            			ee.emit \movedTo _docs[ii], ii, i
            			existing_objs.splice i, 0, id
            	else
            		ee.emit \addedAt, docs[i], i
            		_docs.splice i, 0, docs[i]
            */
          }
          oo[name] = val;
          ee.emit('set', prop, val, prev_val);
          save();
        }
        return val;
      }
    });
    for (k in o) {
      v = o[k];
      reflective[k] = v;
    }
    return reflective;
  };
  Scope._saving[scope_name] = true;
  Scope._[scope_name] = scope = make_reflective({}, '', ee);
  if (initial_obj) {
    debug("initial obj: %O", initial_obj);
    _.each(initial_obj, function(v, k){
      debug("k:%s, v:%O", k, v);
      if (typeof v === 'object' && v !== null) {
        return scope[k] = make_reflective(v, k, save);
      } else {
        return Scope._[scope_name][k] = v;
      }
    });
    Scope._saving[scope_name] = false;
  }
  return scope;
};
Scope._saving = {};
Scope._ = {};
out$.Scope = Scope;